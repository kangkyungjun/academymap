from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, generics, filters
from rest_framework.decorators import api_view
from django.core.cache import cache
from django.conf import settings
from django.db.models import Q
from django_filters.rest_framework import DjangoFilterBackend
from .filters import AcademyFilter, PopularAcademyFilter, NearbyAcademyFilter
from .pagination import StandardResultsSetPagination, SmallResultsSetPagination
import math

from main.models import Data
from .serializers import (
    AcademyListSerializer, 
    AcademyDetailSerializer, 
    AcademySearchSerializer,
    AcademySerializer,
    calculate_distance
)

class AcademyListAPIView(generics.ListAPIView):
    """ÌïôÏõê Î™©Î°ù Ï°∞Ìöå (ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò, ÌïÑÌÑ∞ÎßÅ, Í≤ÄÏÉâ ÏßÄÏõê)"""
    serializer_class = AcademyListSerializer
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_class = AcademyFilter
    search_fields = ['ÏÉÅÌò∏Î™Ö', 'ÎèÑÎ°úÎ™ÖÏ£ºÏÜå', 'ÏãúÎèÑÎ™Ö', 'ÏãúÍµ∞Íµ¨Î™Ö', 'ÌñâÏ†ïÎèôÎ™Ö']
    ordering_fields = ['Î≥ÑÏ†ê', 'ÏÉÅÌò∏Î™Ö', 'id']
    ordering = ['-Î≥ÑÏ†ê', 'id']  # Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÌèâÏ†ê ÎÜíÏùÄ Ïàú, Í∞ôÏùÄ ÌèâÏ†êÏùº ÎïåÎäî ID Ïàú
    pagination_class = StandardResultsSetPagination
    
    def get_queryset(self):
        """ÏÑ±Îä• ÏµúÏ†ÅÌôîÎêú ÏøºÎ¶¨ÏÖã"""
        # Í∏∞Î≥∏ ÏøºÎ¶¨ÏÖã: ÏúÑÎèÑ/Í≤ΩÎèÑÍ∞Ä ÏûàÎäî ÌïôÏõêÎßå (ÏßÄÎèÑ ÌëúÏãúÏö©)
        queryset = Data.objects.filter(
            ÏúÑÎèÑ__isnull=False,
            Í≤ΩÎèÑ__isnull=False
        )
        
        # üöÄ ÏúÑÏπò Í∏∞Î∞ò ÌïÑÌÑ∞ÎßÅ (Îëê Í∞ÄÏßÄ Î™®Îìú ÏßÄÏõê)
        # Mode 1: Geographic bounds (ÏßÄÎèÑ Î∑∞Ìè¨Ìä∏ Í∏∞Î∞ò) - Ïö∞ÏÑ† ÏàúÏúÑ
        sw_lat = self.request.GET.get('sw_lat')
        sw_lng = self.request.GET.get('sw_lng')
        ne_lat = self.request.GET.get('ne_lat')
        ne_lng = self.request.GET.get('ne_lng')

        # Mode 2: Radius-based (ÏÇ¨Ïö©Ïûê ÏúÑÏπò Í∏∞Ï§Ä Î∞òÍ≤Ω)
        lat = self.request.GET.get('lat')
        lon = self.request.GET.get('lon')
        radius = float(self.request.GET.get('radius', 10))  # Í∏∞Î≥∏ 10km

        if sw_lat and sw_lng and ne_lat and ne_lng:
            # Geographic bounds Î™®Îìú (ÏßÄÎèÑ ÏòÅÏó≠ Í∏∞Î∞ò)
            try:
                sw_lat = float(sw_lat)
                sw_lng = float(sw_lng)
                ne_lat = float(ne_lat)
                ne_lng = float(ne_lng)

                queryset = queryset.filter(
                    ÏúÑÎèÑ__gte=sw_lat,
                    ÏúÑÎèÑ__lte=ne_lat,
                    Í≤ΩÎèÑ__gte=sw_lng,
                    Í≤ΩÎèÑ__lte=ne_lng
                )

                # ÏÇ¨Ïö©Ïûê ÏúÑÏπòÍ∞Ä ÏûàÏúºÎ©¥ Í±∞Î¶¨Ïàú Ï†ïÎ†¨ÏùÑ ÏúÑÌï¥ Ï†ÄÏû•
                if lat and lon:
                    self.request.user_lat = float(lat)
                    self.request.user_lon = float(lon)

                print(f"üó∫Ô∏è ÏßÄÎèÑ ÏòÅÏó≠ ÌïÑÌÑ∞ÎßÅ: ({sw_lat}, {sw_lng}) ~ ({ne_lat}, {ne_lng})")
                if lat and lon:
                    print(f"üìç ÏÇ¨Ïö©Ïûê ÏúÑÏπò: ({lat}, {lon}) - Í±∞Î¶¨Ïàú Ï†ïÎ†¨ Ï†ÅÏö©")

            except ValueError:
                print("‚ùå ÏßÄÎèÑ ÏòÅÏó≠ Ï¢åÌëú Î≥ÄÌôò Ïã§Ìå®")

        elif lat and lon:
            # Radius-based Î™®Îìú (ÏÇ¨Ïö©Ïûê ÏúÑÏπò Í∏∞Ï§Ä Î∞òÍ≤Ω)
            try:
                # ÏÇ¨Ïö©Ïûê ÏúÑÏπòÎ•º requestÏóê Ï†ÄÏû•ÌïòÏó¨ serializerÏóêÏÑú ÌôúÏö©
                self.request.user_lat = float(lat)
                self.request.user_lon = float(lon)

                # ÎåÄÎûµÏ†ÅÏù∏ ÏúÑÎèÑ/Í≤ΩÎèÑ Î≤îÏúÑÎ°ú 1Ï∞® ÌïÑÌÑ∞ÎßÅ (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
                lat_range = radius / 111  # 1ÎèÑ ‚âà 111km
                lon_range = radius / (111 * math.cos(math.radians(float(lat))))

                queryset = queryset.filter(
                    ÏúÑÎèÑ__gte=float(lat) - lat_range,
                    ÏúÑÎèÑ__lte=float(lat) + lat_range,
                    Í≤ΩÎèÑ__gte=float(lon) - lon_range,
                    Í≤ΩÎèÑ__lte=float(lon) + lon_range
                )

                print(f"üìç Î∞òÍ≤Ω Í∏∞Î∞ò ÌïÑÌÑ∞ÎßÅ: Ï§ëÏã¨({lat}, {lon}), Î∞òÍ≤Ω {radius}km")

            except ValueError:
                print("‚ùå ÏÇ¨Ïö©Ïûê ÏúÑÏπò Ï¢åÌëú Î≥ÄÌôò Ïã§Ìå®")
        
        # Í≥ºÎ™© ÌïÑÌÑ∞ÎßÅ
        category = self.request.GET.get('category')
        if category and category != 'Ï†ÑÏ≤¥':
            queryset = queryset.filter(**{f'Í≥ºÎ™©_{category}': True})
        
        # Í∞ÄÍ≤© ÌïÑÌÑ∞ÎßÅ (Flutter Ìò∏Ìôò)
        price_min = self.request.GET.get('priceMin')
        price_max = self.request.GET.get('priceMax')
        if price_min or price_max:
            # ÏàòÍ∞ïÎ£åÍ∞Ä ÏûàÎäî ÌïôÏõêÎßå ÎåÄÏÉÅ
            queryset = queryset.exclude(ÏàòÍ∞ïÎ£å_ÌèâÍ∑†__isnull=True).exclude(ÏàòÍ∞ïÎ£å_ÌèâÍ∑†='').exclude(ÏàòÍ∞ïÎ£å_ÌèâÍ∑†='0')
            
            if price_min:
                try:
                    min_price = int(float(price_min))
                    queryset = queryset.extra(
                        where=["CAST(ÏàòÍ∞ïÎ£å_ÌèâÍ∑† AS INTEGER) >= %s"],
                        params=[min_price]
                    )
                except ValueError:
                    pass
                    
            if price_max and price_max != '999999999':
                try:
                    max_price = int(float(price_max))
                    queryset = queryset.extra(
                        where=["CAST(ÏàòÍ∞ïÎ£å_ÌèâÍ∑† AS INTEGER) <= %s"],
                        params=[max_price]
                    )
                except ValueError:
                    pass
        
        # Ïó∞Î†πÎåÄ ÌïÑÌÑ∞ÎßÅ
        age_groups = self.request.GET.getlist('age_groups')
        if age_groups:
            age_filter = Q()
            for age in age_groups:
                age_filter |= Q(**{f'ÎåÄÏÉÅ_{age}': True})
            queryset = queryset.filter(age_filter)
        
        # ÌèâÏ†ê ÌïÑÌÑ∞ÎßÅ
        rating_min = self.request.GET.get('rating_min')
        if rating_min:
            queryset = queryset.filter(Î≥ÑÏ†ê__gte=float(rating_min))
        
        # ÏÖîÌãÄÎ≤ÑÏä§ ÌïÑÌÑ∞ÎßÅ
        if self.request.GET.get('shuttle') == 'true':
            queryset = queryset.exclude(ÏÖîÌãÄÎ≤ÑÏä§__isnull=True).exclude(ÏÖîÌãÄÎ≤ÑÏä§='')

        return queryset

    def list(self, request, *args, **kwargs):
        """üöÄ Í±∞Î¶¨Ïàú Ï†ïÎ†¨ ÏßÄÏõêÏùÑ ÏúÑÌïú Ïª§Ïä§ÌÖÄ list Î©îÏÑúÎìú"""
        queryset = self.get_queryset()

        # ÏÇ¨Ïö©Ïûê ÏúÑÏπòÍ∞Ä ÏûàÍ≥† Í±∞Î¶¨Ïàú Ï†ïÎ†¨Ïù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞
        if hasattr(request, 'user_lat') and hasattr(request, 'user_lon'):
            user_lat = request.user_lat
            user_lng = request.user_lon

            # Í±∞Î¶¨ Í≥ÑÏÇ∞ Î∞è Ï†ïÎ†¨ÏùÑ ÏúÑÌï¥ PythonÏóêÏÑú Ï≤òÎ¶¨
            academies_with_distance = []

            for academy in queryset:
                if academy.ÏúÑÎèÑ and academy.Í≤ΩÎèÑ:
                    distance = calculate_distance(user_lat, user_lng, academy.ÏúÑÎèÑ, academy.Í≤ΩÎèÑ)
                    if distance is not None:
                        academies_with_distance.append((academy, distance))

            # Í±∞Î¶¨ÏàúÏúºÎ°ú Ï†ïÎ†¨
            academies_with_distance.sort(key=lambda x: x[1])

            # Ï†ïÎ†¨Îêú ÏàúÏÑúÎ°ú academy Í∞ùÏ≤¥Îßå Ï∂îÏ∂ú
            sorted_academies = [item[0] for item in academies_with_distance]

            # ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Ï†ÅÏö©
            page = self.paginate_queryset(sorted_academies)
            if page is not None:
                serializer = self.get_serializer(page, many=True)
                return self.get_paginated_response(serializer.data)

            serializer = self.get_serializer(sorted_academies, many=True)
            return Response(serializer.data)

        # Í∏∞Î≥∏ ÎèôÏûë (Í±∞Î¶¨Ïàú Ï†ïÎ†¨Ïù¥ ÌïÑÏöîÌïòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞)
        return super().list(request, *args, **kwargs)

class AcademyDetailAPIView(generics.RetrieveAPIView):
    """ÌïôÏõê ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå"""
    queryset = Data.objects.all()
    serializer_class = AcademyDetailSerializer
    lookup_field = 'pk'

class AcademyNearbyAPIView(APIView):
    """ÏúÑÏπò Í∏∞Î∞ò Ï£ºÎ≥Ä ÌïôÏõê Ï°∞Ìöå"""
    
    def get(self, request):
        lat = request.GET.get('lat')
        lon = request.GET.get('lon')
        radius = float(request.GET.get('radius', 5))  # Í∏∞Î≥∏ 5km
        limit = int(request.GET.get('limit', 20))  # Í∏∞Î≥∏ 20Í∞ú
        
        if not lat or not lon:
            return Response(
                {'error': 'ÏúÑÎèÑ(lat)ÏôÄ Í≤ΩÎèÑ(lon)Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            lat = float(lat)
            lon = float(lon)
        except ValueError:
            return Response(
                {'error': 'Ïò¨Î∞îÎ•∏ ÏúÑÎèÑ, Í≤ΩÎèÑ Í∞íÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.'}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # ÎåÄÎûµÏ†ÅÏù∏ ÏúÑÎèÑ/Í≤ΩÎèÑ Î≤îÏúÑÎ°ú 1Ï∞® ÌïÑÌÑ∞ÎßÅ
        lat_range = radius / 111
        lon_range = radius / (111 * math.cos(math.radians(lat)))
        
        queryset = Data.objects.filter(
            ÏúÑÎèÑ__gte=lat - lat_range,
            ÏúÑÎèÑ__lte=lat + lat_range,
            Í≤ΩÎèÑ__gte=lon - lon_range,
            Í≤ΩÎèÑ__lte=lon + lon_range
        )
        
        # Í±∞Î¶¨ Í≥ÑÏÇ∞ Î∞è Ï†ïÎ†¨
        academies_with_distance = []
        for academy in queryset:
            if academy.ÏúÑÎèÑ and academy.Í≤ΩÎèÑ:
                distance = calculate_distance(lat, lon, academy.ÏúÑÎèÑ, academy.Í≤ΩÎèÑ)
                if distance and distance <= radius:
                    academies_with_distance.append((academy, distance))
        
        # Í±∞Î¶¨Ïàú Ï†ïÎ†¨
        academies_with_distance.sort(key=lambda x: x[1])
        nearby_academies = [item[0] for item in academies_with_distance[:limit]]
        
        # ÏÇ¨Ïö©Ïûê ÏúÑÏπòÎ•º requestÏóê Ï†ÄÏû•
        request.user_lat = lat
        request.user_lon = lon
        
        serializer = AcademyListSerializer(nearby_academies, many=True, context={'request': request})
        
        return Response({
            'count': len(nearby_academies),
            'results': serializer.data
        })

@api_view(['GET'])
def categories_view(request):
    """ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Î∞òÌôò (Ï∫êÏã± Ï†ÅÏö©)"""
    cache_key = 'api:categories'
    categories = cache.get(cache_key)
    
    if categories is None:
        categories = [
            {'key': 'Ï¢ÖÌï©', 'name': 'Ï¢ÖÌï©'},
            {'key': 'ÏàòÌïô', 'name': 'ÏàòÌïô'},
            {'key': 'ÏòÅÏñ¥', 'name': 'ÏòÅÏñ¥'},
            {'key': 'Í≥ºÌïô', 'name': 'Í≥ºÌïô'},
            {'key': 'Ïô∏Íµ≠Ïñ¥', 'name': 'Ïô∏Íµ≠Ïñ¥'},
            {'key': 'ÏòàÏ≤¥Îä•', 'name': 'ÏòàÏ≤¥Îä•'},
            {'key': 'Ïª¥Ìì®ÌÑ∞', 'name': 'Ïª¥Ìì®ÌÑ∞'},
            {'key': 'ÎÖºÏà†', 'name': 'ÎÖºÏà†'},
            {'key': 'Í∏∞ÌÉÄ', 'name': 'Í∏∞ÌÉÄ'},
            {'key': 'ÎèÖÏÑúÏã§Ïä§ÌÑ∞ÎîîÏπ¥Ìéò', 'name': 'ÎèÖÏÑúÏã§/Ïä§ÌÑ∞ÎîîÏπ¥Ìéò'},
        ]
        cache.set(cache_key, categories, getattr(settings, 'STATS_CACHE_TIMEOUT', 3600))
    
    return Response({'categories': categories})

@api_view(['GET'])
def regions_view(request):
    """ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÏßÄÏó≠ Î™©Î°ù Î∞òÌôò"""
    regions = Data.objects.values('ÏãúÎèÑÎ™Ö', 'ÏãúÍµ∞Íµ¨Î™Ö').distinct().order_by('ÏãúÎèÑÎ™Ö', 'ÏãúÍµ∞Íµ¨Î™Ö')
    
    # ÏãúÎèÑÎ™ÖÎ≥ÑÎ°ú Í∑∏Î£πÌïë
    regions_dict = {}
    for region in regions:
        ÏãúÎèÑ = region['ÏãúÎèÑÎ™Ö']
        ÏãúÍµ∞Íµ¨ = region['ÏãúÍµ∞Íµ¨Î™Ö']
        
        if ÏãúÎèÑ not in regions_dict:
            regions_dict[ÏãúÎèÑ] = []
        if ÏãúÍµ∞Íµ¨ and ÏãúÍµ∞Íµ¨ not in regions_dict[ÏãúÎèÑ]:
            regions_dict[ÏãúÎèÑ].append(ÏãúÍµ∞Íµ¨)
    
    # Ï†ïÎ†¨
    for key in regions_dict:
        regions_dict[key].sort()
    
    return Response({'regions': regions_dict})

class AcademySearchAPIView(APIView):
    """Í≥†Í∏â Í≤ÄÏÉâ API"""
    
    def post(self, request):
        search_serializer = AcademySearchSerializer(data=request.data)
        
        if not search_serializer.is_valid():
            return Response(search_serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        data = search_serializer.validated_data
        queryset = Data.objects.all()
        
        # ÌÖçÏä§Ìä∏ Í≤ÄÏÉâ
        query = data.get('query')
        if query:
            queryset = queryset.filter(
                Q(ÏÉÅÌò∏Î™Ö__icontains=query) |
                Q(ÎèÑÎ°úÎ™ÖÏ£ºÏÜå__icontains=query) |
                Q(ÏãúÎèÑÎ™Ö__icontains=query) |
                Q(ÏãúÍµ∞Íµ¨Î™Ö__icontains=query) |
                Q(ÌñâÏ†ïÎèôÎ™Ö__icontains=query)
            )
        
        # Ïπ¥ÌÖåÍ≥†Î¶¨ ÌïÑÌÑ∞
        category = data.get('category')
        if category and category != 'Ï†ÑÏ≤¥':
            queryset = queryset.filter(**{f'Í≥ºÎ™©_{category}': True})
        
        # Í∞ÄÍ≤© ÌïÑÌÑ∞ (ÏàòÍ∞ïÎ£å_ÌèâÍ∑† ÌïÑÎìú Í∏∞Ï§Ä)
        price_min = data.get('price_min')
        price_max = data.get('price_max')
        if price_min or price_max:
            # ÏàòÍ∞ïÎ£åÍ∞Ä ÏûàÎäî ÌïôÏõêÎßå ÎåÄÏÉÅ
            price_queryset = queryset.exclude(ÏàòÍ∞ïÎ£å_ÌèâÍ∑†__isnull=True).exclude(ÏàòÍ∞ïÎ£å_ÌèâÍ∑†='').exclude(ÏàòÍ∞ïÎ£å_ÌèâÍ∑†='0')
            
            if price_min:
                try:
                    min_price = int(price_min)
                    # CastÎ•º ÏÇ¨Ïö©Ìï¥ Î¨∏ÏûêÏó¥ÏùÑ Ï†ïÏàòÎ°ú Î≥ÄÌôòÌïòÏó¨ ÎπÑÍµê
                    from django.db.models import Cast, IntegerField
                    price_queryset = price_queryset.extra(
                        where=["CAST(ÏàòÍ∞ïÎ£å_ÌèâÍ∑† AS INTEGER) >= %s"],
                        params=[min_price]
                    )
                except ValueError:
                    pass
                    
            if price_max:
                try:
                    max_price = int(price_max) if price_max != '999999999' else 10000000
                    from django.db.models import Cast, IntegerField  
                    price_queryset = price_queryset.extra(
                        where=["CAST(ÏàòÍ∞ïÎ£å_ÌèâÍ∑† AS INTEGER) <= %s"],
                        params=[max_price]
                    )
                except ValueError:
                    pass
                    
            queryset = price_queryset
        
        # Ïó∞Î†πÎåÄ ÌïÑÌÑ∞
        age_groups = data.get('age_groups', [])
        if age_groups:
            age_filter = Q()
            for age in age_groups:
                age_filter |= Q(**{f'ÎåÄÏÉÅ_{age}': True})
            queryset = queryset.filter(age_filter)
        
        # ÌèâÏ†ê ÌïÑÌÑ∞
        rating_min = data.get('rating_min')
        if rating_min:
            queryset = queryset.filter(Î≥ÑÏ†ê__gte=rating_min)
        
        # ÏÖîÌãÄÎ≤ÑÏä§ ÌïÑÌÑ∞
        if data.get('shuttle'):
            queryset = queryset.exclude(ÏÖîÌãÄÎ≤ÑÏä§__isnull=True).exclude(ÏÖîÌãÄÎ≤ÑÏä§='')
        
        # ÏúÑÏπò Í∏∞Î∞ò ÌïÑÌÑ∞ÎßÅ
        lat = data.get('lat')
        lon = data.get('lon')
        radius = data.get('radius', 5.0)
        
        if lat and lon:
            request.user_lat = lat
            request.user_lon = lon
            
            # ÎåÄÎûµÏ†ÅÏù∏ Î≤îÏúÑÎ°ú 1Ï∞® ÌïÑÌÑ∞ÎßÅ
            lat_range = radius / 111
            lon_range = radius / (111 * math.cos(math.radians(lat)))
            
            queryset = queryset.filter(
                ÏúÑÎèÑ__gte=lat - lat_range,
                ÏúÑÎèÑ__lte=lat + lat_range,
                Í≤ΩÎèÑ__gte=lon - lon_range,
                Í≤ΩÎèÑ__lte=lon + lon_range
            )
        
        # ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖòÏùÄ DRFÏùò Í∏∞Î≥∏ ÏÑ§Ï†ï ÏÇ¨Ïö©
        from rest_framework.pagination import PageNumberPagination
        paginator = PageNumberPagination()
        paginated_queryset = paginator.paginate_queryset(queryset, request)
        
        serializer = AcademyListSerializer(
            paginated_queryset, 
            many=True, 
            context={'request': request}
        )
        
        return paginator.get_paginated_response(serializer.data)

# Ï∂îÍ∞Ä ÌäπÌôî Î∑∞Îì§
class PopularAcademiesAPIView(generics.ListAPIView):
    """Ïù∏Í∏∞ ÌïôÏõê Î™©Î°ù (ÌèâÏ†ê, ÏÇ¨ÏßÑ Í∏∞Ï§Ä)"""
    serializer_class = AcademyListSerializer
    filter_backends = [DjangoFilterBackend, filters.OrderingFilter]
    filterset_class = PopularAcademyFilter
    ordering = ['-Î≥ÑÏ†ê', 'id']
    
    def get_queryset(self):
        # ÌèâÏ†êÏù¥ ÏûàÍ≥†, ÏÇ¨ÏßÑÏù¥ ÏûàÎäî ÌïôÏõêÎì§Îßå Ï∂îÏ≤ú
        return Data.objects.filter(
            Î≥ÑÏ†ê__isnull=False,
            Î≥ÑÏ†ê__gte=4.0
        ).exclude(
            ÌïôÏõêÏÇ¨ÏßÑ__isnull=True
        ).exclude(
            ÌïôÏõêÏÇ¨ÏßÑ=''
        )

class RecommendedAcademiesAPIView(APIView):
    """Ï∂îÏ≤ú ÌïôÏõê Î™©Î°ù (Îã§ÏñëÌïú Í∏∞Ï§Ä Ï°∞Ìï©)"""
    
    def get(self, request):
        category = request.GET.get('category')
        age_group = request.GET.get('age_group')
        limit = int(request.GET.get('limit', 10))
        
        # Í∏∞Î≥∏ Ï∂îÏ≤ú Í∏∞Ï§Ä: ÌèâÏ†ê ÎÜíÍ≥† Ï†ïÎ≥¥Í∞Ä Ï∂©Ïã§Ìïú ÌïôÏõêÎì§
        base_queryset = Data.objects.filter(
            Î≥ÑÏ†ê__isnull=False,
            Î≥ÑÏ†ê__gte=3.5
        )
        
        # Ïπ¥ÌÖåÍ≥†Î¶¨ Í∏∞Î∞ò Ï∂îÏ≤ú
        if category and category != 'Ï†ÑÏ≤¥':
            base_queryset = base_queryset.filter(**{f'Í≥ºÎ™©_{category}': True})
        
        # Ïó∞Î†πÎåÄ Í∏∞Î∞ò Ï∂îÏ≤ú
        if age_group:
            base_queryset = base_queryset.filter(**{f'ÎåÄÏÉÅ_{age_group}': True})
        
        # Ï∂îÏ≤ú ÏïåÍ≥†Î¶¨Ï¶ò: ÌèâÏ†ê + Ï†ïÎ≥¥ ÏôÑÏÑ±ÎèÑ
        recommended = base_queryset.extra(
            select={
                'score': """
                    CASE 
                        WHEN Î≥ÑÏ†ê >= 4.5 THEN 100
                        WHEN Î≥ÑÏ†ê >= 4.0 THEN 80
                        WHEN Î≥ÑÏ†ê >= 3.5 THEN 60
                        ELSE 40
                    END +
                    CASE WHEN ÌïôÏõêÏÇ¨ÏßÑ IS NOT NULL AND ÌïôÏõêÏÇ¨ÏßÑ != '' THEN 20 ELSE 0 END +
                    CASE WHEN ÏÜåÍ∞úÍ∏Ä IS NOT NULL AND ÏÜåÍ∞úÍ∏Ä != '' THEN 10 ELSE 0 END +
                    CASE WHEN Ï†ÑÌôîÎ≤àÌò∏ IS NOT NULL AND Ï†ÑÌôîÎ≤àÌò∏ != '' THEN 10 ELSE 0 END +
                    CASE WHEN ÏÖîÌãÄÎ≤ÑÏä§ IS NOT NULL AND ÏÖîÌãÄÎ≤ÑÏä§ != '' THEN 5 ELSE 0 END
                """
            }
        ).order_by('-score', '-Î≥ÑÏ†ê', 'id')[:limit]
        
        serializer = AcademyListSerializer(recommended, many=True, context={'request': request})
        
        return Response({
            'count': len(recommended),
            'results': serializer.data,
            'recommendation_criteria': {
                'category': category,
                'age_group': age_group,
                'min_rating': 3.5,
                'factors': ['rating', 'photo', 'description', 'contact', 'shuttle']
            }
        })

@api_view(['GET'])
def academy_stats_view(request):
    """ÌïôÏõê ÌÜµÍ≥Ñ Ï†ïÎ≥¥ (Ï∫êÏã± Ï†ÅÏö©)"""
    cache_key = 'api:academy_stats'
    stats = cache.get(cache_key)
    
    if stats is None:
        from django.db.models import Count, Avg
        
        # Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ
        total_count = Data.objects.count()
        avg_rating = Data.objects.filter(Î≥ÑÏ†ê__isnull=False).aggregate(Avg('Î≥ÑÏ†ê'))['Î≥ÑÏ†ê__avg']
        
        # ÏßÄÏó≠Î≥Ñ ÌÜµÍ≥Ñ
        region_stats = Data.objects.values('ÏãúÎèÑÎ™Ö').annotate(
            count=Count('id')
        ).order_by('-count')[:10]
        
        # Í≥ºÎ™©Î≥Ñ ÌÜµÍ≥Ñ
        subject_stats = {}
        subjects = ['Ï¢ÖÌï©', 'ÏàòÌïô', 'ÏòÅÏñ¥', 'Í≥ºÌïô', 'Ïô∏Íµ≠Ïñ¥', 'ÏòàÏ≤¥Îä•', 'Ïª¥Ìì®ÌÑ∞', 'ÎÖºÏà†', 'Í∏∞ÌÉÄ', 'ÎèÖÏÑúÏã§Ïä§ÌÑ∞ÎîîÏπ¥Ìéò']
        for subject in subjects:
            count = Data.objects.filter(**{f'Í≥ºÎ™©_{subject}': True}).count()
            subject_stats[subject] = count
        
        # Ïó∞Î†πÎåÄÎ≥Ñ ÌÜµÍ≥Ñ
        age_stats = {}
        ages = ['Ïú†ÏïÑ', 'Ï¥àÎì±', 'Ï§ëÎì±', 'Í≥†Îì±', 'ÌäπÎ™©Í≥†', 'ÏùºÎ∞ò', 'Í∏∞ÌÉÄ']
        for age in ages:
            count = Data.objects.filter(**{f'ÎåÄÏÉÅ_{age}': True}).count()
            age_stats[age] = count
        
        stats = {
            'total_academies': total_count,
            'average_rating': round(avg_rating, 2) if avg_rating else None,
            'top_regions': list(region_stats),
            'subject_distribution': subject_stats,
            'age_group_distribution': age_stats,
            'academies_with_photos': Data.objects.exclude(
                ÌïôÏõêÏÇ¨ÏßÑ__isnull=True
            ).exclude(ÌïôÏõêÏÇ¨ÏßÑ='').count(),
            'academies_with_shuttle': Data.objects.exclude(
                ÏÖîÌãÄÎ≤ÑÏä§__isnull=True
            ).exclude(ÏÖîÌãÄÎ≤ÑÏä§='').count(),
        }
        
        cache.set(cache_key, stats, getattr(settings, 'STATS_CACHE_TIMEOUT', 3600))
    
    return Response(stats)

@api_view(['POST'])
def autocomplete_view(request):
    """ÏûêÎèôÏôÑÏÑ± API"""
    query = request.data.get('query', '').strip()
    limit = int(request.data.get('limit', 10))
    
    if len(query) < 2:
        return Response({'suggestions': []})
    
    # ÌïôÏõêÎ™Ö ÏûêÎèôÏôÑÏÑ±
    academy_names = Data.objects.filter(
        ÏÉÅÌò∏Î™Ö__icontains=query
    ).values_list('ÏÉÅÌò∏Î™Ö', flat=True).distinct()[:limit//2]
    
    # ÏßÄÏó≠ ÏûêÎèôÏôÑÏÑ±
    regions = Data.objects.filter(
        Q(ÏãúÎèÑÎ™Ö__icontains=query) |
        Q(ÏãúÍµ∞Íµ¨Î™Ö__icontains=query) |
        Q(ÌñâÏ†ïÎèôÎ™Ö__icontains=query)
    ).values('ÏãúÎèÑÎ™Ö', 'ÏãúÍµ∞Íµ¨Î™Ö', 'ÌñâÏ†ïÎèôÎ™Ö').distinct()[:limit//2]
    
    region_suggestions = []
    for region in regions:
        region_text = f"{region['ÏãúÎèÑÎ™Ö']} {region['ÏãúÍµ∞Íµ¨Î™Ö']} {region['ÌñâÏ†ïÎèôÎ™Ö']}"
        region_suggestions.append(region_text)
    
    suggestions = {
        'academies': list(academy_names),
        'regions': region_suggestions,
        'total': len(academy_names) + len(region_suggestions)
    }
    
    return Response({'suggestions': suggestions})

# API Ìó¨Ïä§Ï≤¥ÌÅ¨ Î∞è Ï†ïÎ≥¥ Ï†úÍ≥µ
@api_view(['GET'])
def api_info_view(request):
    """API Ï†ïÎ≥¥ Î∞è Ìó¨Ïä§Ï≤¥ÌÅ¨"""
    from django.db import connection
    import time
    
    start_time = time.time()
    
    # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
    try:
        with connection.cursor() as cursor:
            cursor.execute("SELECT 1")
        db_status = "healthy"
        db_time = round((time.time() - start_time) * 1000, 2)  # ms
    except Exception as e:
        db_status = "error"
        db_time = None
    
    api_info = {
        'api_version': 'v1',
        'service': 'AcademyMap API',
        'status': 'healthy',
        'timestamp': time.time(),
        'database': {
            'status': db_status,
            'response_time_ms': db_time
        },
        'endpoints': {
            'academies': '/api/v1/academies/',
            'academy_detail': '/api/v1/academies/{id}/',
            'nearby': '/api/v1/academies/nearby/',
            'search': '/api/v1/academies/search/',
            'popular': '/api/v1/academies/popular/',
            'recommended': '/api/v1/academies/recommended/',
            'categories': '/api/v1/categories/',
            'regions': '/api/v1/regions/',
            'stats': '/api/v1/stats/',
            'autocomplete': '/api/v1/autocomplete/',
        },
        'features': [
            'location-based search',
            'advanced filtering',
            'recommendation system',
            'autocomplete',
            'pagination',
            'caching',
            'real-time distance calculation'
        ]
    }
    
    return Response(api_info)

# ÌïòÏúÑ Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú Í∏∞Ï°¥ Î∑∞
class AcademyListAPIViewLegacy(AcademyListAPIView):
    """Í∏∞Ï°¥ API Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú Î∑∞"""
    serializer_class = AcademySerializer
